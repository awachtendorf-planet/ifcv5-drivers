package datachange

import (
	"fmt"
	"time"

	honeywell "github.com/weareplanet/ifcv5-drivers/honeywell/dispatcher"
	ifc "github.com/weareplanet/ifcv5-main/ifc/base"
	"github.com/weareplanet/ifcv5-main/ifc/generic/dispatcher"
	automatestate "github.com/weareplanet/ifcv5-main/ifc/generic/state/automate"
	order "github.com/weareplanet/ifcv5-main/ifc/job"
	"github.com/weareplanet/ifcv5-main/log"

	dc "github.com/weareplanet/ifcv5-main/ifc/automate/generic"

	"github.com/weareplanet/ifcv5-drivers/honeywell/dispatcher"
	"github.com/weareplanet/ifcv5-drivers/honeywell/template"
)

// Plugin ...
type Plugin struct {
	*dc.Plugin
	driver *honeywell.Dispatcher
}

// New return a new plugin
func New(parent *honeywell.Dispatcher) *Plugin {

	p := &Plugin{
		dc.New(),
		parent,
	}

	p.Setup(dc.Config{

		Name: fmt.Sprintf("%T", p),

		GetAnswerTimeout:   func(_ string, _ *order.Job) time.Duration { return 30 * time.Second },
		WaitForReplyPacket: p.waitForReplayPacket,

		InitHandler:     p.init,
		SendPacket:      p.send,
		PreCheck:        p.preCheck,
		ProcessWorkflow: p.processWorkflow,

		TemplateAck: template.PacketAck,
		TemplateNak: template.PacketNak,
	})

	return p
}

func (p *Plugin) init() {

	p.RegisterWorkflow(order.Checkin, template.PacketCheckIn)
	p.RegisterWorkflow(order.Checkout, template.PacketCheckOut)

	p.RegisterRule(template.PacketResponse, automatestate.WaitForAnswer, p.handleReply, dispatcher.StateAction{NextState: automatestate.NextRecord})

}

func (p *Plugin) preCheck(_ string, job *order.Job) (bool, error) {

	// pre check again, because of orders possibly generated by generic db sync automate

	driver := p.driver

	room := driver.GetRoom(job.Context)
	if err := driver.CheckRoom(room); err != nil {
		return false, err
	}

	return true, nil
}

func (p *Plugin) processWorkflow(addr string, _ string, job *order.Job) bool {

	driver := p.driver

	if driver.IsSharer(job.Context) {

		name := p.GetName()
		log.Debug().Msgf("%s addr '%s' ignore packet, because of sharer flag is set", name, addr)
		return false

	}

	return true
}

func (p *Plugin) waitForReplayPacket(addr string, job *order.Job) bool {

	driver := p.driver

	station, _ := driver.GetStationAddr(addr)
	protocol := driver.GetProtocolType(station)

	switch protocol {

	case honeywell.HONEYWELL_PROTOCOL:
		return true

	case honeywell.ALERTON_PROTOCOL_1, honeywell.ALERTON_PROTOCOL_2:
		return false

	}

	return false
}

func (p *Plugin) handleReply(addr string, in *ifc.LogicalPacket, action *dispatcher.StateAction, job *order.Job) error {

	request := in.Data()["Request"]

	if len(request) < 1 || (job.Action == order.Checkin && request[0] != 'I') || job.Action == order.Checkout && request[0] != 'O' {

		p.HandleError(addr, job, "vendor has replied with unexpected record")
		p.ChangeState(addr, automatestate.Success)
		return nil

	}

	answer := in.Data()["Answer"]

	if len(answer) < 1 || (answer[0] != 0x06 && answer[0] != 0x15) {

		p.HandleError(addr, job, "vendor has replied with unknown status")
		p.ChangeState(addr, automatestate.Success)
		return nil

	}

	if answer[0] == 0x15 {

		p.HandleError(addr, job, "vendor refused the record")
		p.ChangeState(addr, automatestate.Success)
		return nil

	}

	p.ChangeState(addr, action.NextState)

	return nil
}

func (p *Plugin) send(addr string, action *dispatcher.StateAction, packetName string, tracking string, context interface{}, _ *order.Job) error {

	packet, err := p.driver.ConstructPacket(addr, packetName, tracking, context)
	if err != nil {
		return err
	}

	err = p.SendPacket(addr, packet, action)

	return err
}
